/* MAIN.C file
 * Дата создания 03.07.2023
 Автор: Никита
 Рандомная бегущая строка на основе STM8S003F3P6
 * Copyright (c) 2002-2005 STMicroelectronics
 */
#include "stm8s.h"
//#include "stm8_interrupt_vector.h"
//==========================================================
unsigned int next;//для расчёта бегущей строки
unsigned int next2;
//unsigned char *address_1 = (unsigned char*)0x4000;// = 0x4000; присваиваем адрес в ПЗУ (EEPROM) переменной address
unsigned char alar;
int eff111[36];
int buf[36];
int iii = 0;
int ii = 0;
int y = 0;
int l = 10;
int i = 0;	
int fraim;
int x;
int xx = 0;
int xxx = 0;
unsigned char sec;
unsigned char min;
unsigned char hour;
unsigned char SB1;//Переменная счёта нажатий кнопки SB1
unsigned char swres = 0;//Переменная разрешения нажатий кнопки SB1
unsigned int ip;
unsigned int speed = 450;//Переменная для хранения значения скорости строки 450
unsigned int butcount = 0;//Переменная для функции подавления дребезга
#define dev_addrw 0b11010000 //запись 
#define dev_addrr 0b11010001 //чтение
//=========================Задержка=========================
 void delay(int n)
 {
         while(n > 10) n--;
 }
 //========================Обработка прерывания=============
@far @interrupt void EXTI3_IRQHandler(void) 
{
	butcount = 0;
	if (swres == 0) SB1 ++;
	if (SB1 >= 5) SB1 = 0;
	while (!((GPIOD->IDR & (1 << 1)))){//нажатие кнопки SB2 изменение скорости
	if (butcount < 10000){
			butcount ++;
					}
		else {
			swres = 1;
	switch (SB1){
				case 0:
		speed = 450;
		break;
				case 1:
		speed = 350;
		break;
				case 2:
		speed = 250;
		break;
				case 3:
		speed = 150;
		break;
				case 4:
		speed = 50;
		break;
	}
}
}
return;
}
//============Инициализация микросхемы DC1307===============
void DS1307init (void){//
					I2C->CR1 |= (1<<0);//включаем I2C
					//if (alar == 0){
					I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					//while(I2C->SR1 & (1 << 0) != 1){}//ждём установки стартового бита 1
					delay (500);//delay (250);
					I2C->DR = dev_addrw;//адрес часовой микросхемы - запись
					while(I2C->SR1 & (1 << 1) == 1){}//ждём конца передачи адрес 1
					while(I2C->CR2 & (1 << 2) == 1){}//получили ACK 1
					delay (500);//delay (200);
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					while((I2C->SR1 & (1 << 2)) && (I2C->SR1 & (1 << 7)) == 1){}//
          xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					I2C->DR = 0b00000000;//вызов регистра секунд
					delay (350);//delay (450);
          I2C->DR &= ~(1 << 7);//отправка данных
					while(I2C->SR1 & (1 << 7) == 1){}//ждём освобождения регистра данны
					I2C->CR2 |= (1<<1);//отправка посылки СТОП
					alar = 1;
					//*address_1 = alar;
//}
					
					delay (5000);//delay (250);
					I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					while(I2C->SR1 & (1 << 0) != 1){}//ждём установки стартового бита 1
					delay (500);//delay (50);
					I2C->DR = dev_addrw;//адрес часовой микросхемы - запись
					while(I2C->SR1 & (1 << 1) == 1){}//ждём конца передачи адрес 1
					while(I2C->CR2 & (1 << 2) == 1){}//получили ACK 1
					delay (500);//delay (100);
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					while((I2C->SR1 & (1 << 2)) && (I2C->SR1 & (1 << 7)) == 1){}//
          xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					I2C->DR = 0b00000111;//вызов регистра clock out  0b00000111
					delay (600);//delay (250);
          I2C->DR = 0b00010000;//отправка данных0b00010000 включаем свеитодиод
					while(I2C->SR1 & (1 << 7) == 1){}//ждём освобождения регистра данны
					I2C->CR2 |= (1<<1);//отправка посылки СТОП		
					
					return;
}
//========================Чтение минут====================
int DS07read (void){//чтение секунд
					delay (5000);//delay (250);
					//I2C->CR1 |= (1<<0);//включаем I2C
					I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					while(I2C->SR1 & (1 << 0) != 1){}//ждём установки стартового бита 1
					delay (500);//delay (50);
					I2C->DR = dev_addrw;//адрес часовой микросхемы - 
					while(I2C->SR1 & (1 << 1) == 1){}//ждём конца передачи адрес 1
					while(I2C->CR2 & (1 << 2) == 1){}//получили ACK 1
					delay (500);//delay (100);
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					while((I2C->SR1 & (1 << 2)) && (I2C->SR1 & (1 << 7)) == 1){}//
          xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					I2C->DR = 0b00000001;//вызов регистра минут
					delay (600);//delay (250);
          //I2C->DR &= ~(1 << 7);//отправка данных
					while(I2C->SR1 & (1 << 7) == 1){}//ждём освобождения регистра данны
					I2C->CR2 |= (1<<1);//отправка посылки СТОП
					/*
					delay (200);//delay (100);
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					I2C->CR2 |= (1<<1);//отправка посылки СТОП
					*/
					
					I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					while(I2C->SR1 & (1 << 0) != 1){}//ждём установки стартового бита 1
					delay (500);//delay (50);
					I2C->DR = dev_addrr;//адрес часовой микросхемы
					while(I2C->SR1 & (1 << 1) == 1){}//ждём конца передачи адрес 1
					while(I2C->CR2 & (1 << 2) == 1){}//получили ACK 1
					delay (500);//delay (100);
					xxx = I2C->SR1;//Очистка бита ADDR чтением регистра SR3
					xxx = I2C->SR3;//Очистка бита ADDR чтением регистра SR3
					delay (600);//delay (100);
					//xxx = I2C->DR;
					next = I2C->DR;
					//while(I2C->SR1 & (1 << 7) == 1){}//ждём освобождения регистра данны
					I2C->CR2 |= (1<<1);//отправка посылки СТОП
					//xxx = xxx & 0b11110000;
					next = next & 0b11110000;
return;
}
//==========================================================
	void raand(unsigned int jk)
		 {
			 //next = GPIOD->ODR
		 unsigned char i2;
			int xy;
			//next++;
			//next = 5;
			//jk++;
		 if (jk > 20) next = 2;
		 for (i2 = 0; i2 < 36; i2++){
		 jk = jk * 1103515;//1103515245
		   next2 = (jk / 655) * 276;// next2 = (next / 65536) * 2768
		   xy = next2 % (327 - 8 + 1) + 8;//x = next2 % (32767 - 8 + 1) + 8
		   if (xy > 327) xy = xy - 327;//if (x > 32767) x = x - 32767;
		 eff111[i2] = xy;//0
		 }
	}
 //=====================
 void clear_matrix(void)
 {
 	 unsigned char i;
 	 for (i = 0;i < 49; i++){
 		 eff111[i] = 0;
 	 }
 }
//==========================ВЫВОД ФРЕЙМА====================
	void fraim_out (int o, int e){
			if (iii > 48) {//Перезапись массива
		//DS07read();
	 			raand(DS07read());
	 			iii = 0;
				fraim = 1;
	 		}

	 	 			//if (o == 0){
						iii++;
						buf[35] = eff111[0];//Считали 1ю колонку в буфер
						for ( ii = 0; ii < 35; ii++){
						eff111[ii] = eff111[ii + 1];//Сдвинули матрицу на один столбец влево
						}
						eff111[35] = buf[35];//Записали содержимое буфера (первую колонку) в конец матрицы
					//}
					/*if (o == 1){
						iii++;
						buf[28] = numbers[0];//Считали 1ю колонку в буфер
						for ( ii = 0; ii < 28; ii++){
						numbers[ii] = numbers[ii + 1];//Сдвинули матрицу на один столбец влево
						}
						numbers[28] = buf[28];
				    if (iii == 14) fraim = 0;						
					}*/

	for ( ip = 0; ip < speed; ++ip){//400  speed
					//if (o == 0){
						GPIOC->ODR = eff111[l];//	
					//}
					//else{
					//	GPIOC->ODR = numbers[l];	
					//}
					/*GPIOA->ODR &= ~(1<<3);
					delay (1000);//скорость бега строки
					GPIOA->ODR |= (1<<3);
				*/
					GPIOD->ODR &= ~(1<<6);
					delay (1000);//скорость бега строки1000
					GPIOD->ODR |= (1<<6);
					
					GPIOC->ODR &= ~((1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3));//очистка строк ++
					l--;
	 	 			y++;
	 	 			if (y == 8){
	 	 				y = 0;
	 	 				l = 8;
						/*
						GPIOD->ODR |= (1<<6);//переключение столбца CLOCK ИЕ8
						delay (20);
						GPIOD->ODR &= ~(1<<6);//переключение столбца CLOCK ИЕ8
						*/
						GPIOA->ODR |= (1<<3);//переключение столбца CLOCK ИЕ8
						delay (20);
						GPIOA->ODR &= ~(1<<3);//переключение столбца CLOCK ИЕ8
	 	 			}
	}
	}
//==========================================================
int main(void)
{
//ODR регистр выходных данных
//IDR регистр входных данных
//DDR регистр направления данных
//0: Input mode
//1: Output mode
//Настройка портов
//while ((GPIOD->IDR & (1 << 5)))проверка порта - если 1, то работаем
//while (!((GPIOD->IDR & (1 << 5))))проверка порта - если 0, то работаем
  CLK->ECKR |= (1<<0);//Включение HSE осцилятора
	CLK->SWCR |= (1<<1);//Разрешаем переключить источник тактирования
while(CLK->ECKR & (1<<1) == 1){}//Ждем готовности источника тактирования
	CLK->CKDIVR = 0b00011000;//Делитель частоты внутреннего осцилятора = 0; тактовой частоты ЦПУ -2  11000
  CLK->SWR = 0b10110100;//HSE основной источник синхронизации
while (CLK->SWCR & (1<<1) == 1){}// Ждем готовности переключения
	CLK->PCKENR1 = 0b00000001;//включаем тактирование I2C
	
	
	GPIOA->DDR |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Выход
	GPIOA->CR1 |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Выход типа Push-pull
	GPIOA->CR2 |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Скорость переключения - до 10 МГц.
	
	GPIOD->DDR &= ~((1<<5) | (1<<3) | (1<<2) | (1<<1));//Вход | (1<<4)
	GPIOD->CR1 |= (1<<3) | (1<<2) | (1<<1);//Вход с подтягивающим резистором
	GPIOD->CR2 |= (1<<3) | (1<<2) | (1<<1);//Прерывание включено
	GPIOD->DDR |= (1<<6) | (1<<4);//Выход
  GPIOD->CR1 |= (1<<6) | (1<<4);//
	GPIOD->CR2 |= (1<<6) | (1<<4);//
	
	GPIOC->DDR |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//выход
	GPIOC->CR1 |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//Выход типа Push-pull 
	GPIOC->CR2 |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//Скорость переключения - до 10 МГц.
	
	GPIOB->ODR |= (1<<5) | (1<<4);//устанавливаем 1
	GPIOB->DDR |= (1<<5) | (1<<4);//Выход
	GPIOB->CR1 &= ~((1<<5) | (1<<4));//Выход типа Open Drain
	GPIOB->CR2 &= ~((1<<5) | (1<<4));//Скорость переключения - до 10 МГц.
	//===================Настройка I2C========================
		I2C->CR1 &= ~(1<<0);//отключаем I2C перед настройкой
		I2C->FREQR = 8;//частота переферии 8МГц
		I2C->CCRL = 80;//100kHz
		I2C->CCRH = 0;
		//I2C->CCRH |= (1<<3) | (1<<2) | (1<<0);//13
		//I2C->CCRH |= (1<<3) | (1<<2);//12
		//I2C->CCRH |= (1<<3) | (1<<1);//10
		//I2C->CCRH |= (1<<2) | (1<<1);//6
		//I2C->CCRH |= (1<<1) | (1<<0);//3
		//I2C->CCRH |= (1<<3) | (1<<2) | (1<<1) | (1<<0);//15
		I2C->TRISER = 9;//rise time 1000ns
		//I2C->OARL = 0xA0;              // own address A0;
		//I2C->OARH |= 0x40;
		I2C->ITR = 0;                  // enable error interrupts
		I2C->CR2 |= 0x04;              // ACK=1, Ack enable
		I2C->CR1 |= 0x01;              // PE=1
		
	//========================================================
	/*GPIOD->ODR |= (1<<6);
	delay (20);
	GPIOD->ODR &= ~(1<<6);
	*/
	GPIOA->ODR |= (1<<3);
	delay (20);
	GPIOA->ODR &= ~(1<<3);
	
	delay (5000);
    DS1307init();
	delay (5000);	
		//DS07read();
			delay (50000);
		raand(DS07read());


ITC->ISPR2 &= ~((1<<5) | (1<<4));//+
ITC->ISPR2 |= (1<<5) | (1<<4);//+




EXTI->CR1 = 0b10000000;//Прерывание по заднему фронту
//ITC->ISPR2 &= ~((1<<5) | (1<<4));//+

rim();
//enableInterrupts();


	while (1){
		unsigned char iu;


		fraim_out(fraim, 0);

swres = 0;//Разрешение переключения скорости


				/*
				Рабочая
		I2C->CR1 &= ~(1<<0);//отключаем I2C перед настройкой
		I2C->FREQR = 8;//частота переферии 8МГц
		I2C->CCRL = 40;//100kHz
		I2C->CCRH = 0;//
		I2C->TRISER = 9;//rise time 1000ns
		I2C->OARL = 0xA0;              // own address A0;
		I2C->OARH |= 0x40;
		I2C->ITR = 1;                  // enable error interrupts
		I2C->CR2 |= 0x04;              // ACK=1, Ack enable
		I2C->CR1 |= 0x01;              // PE=1
				*/
						}
}




