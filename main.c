/* MAIN.C file
 * Дата создания 03.07.2023
 Автор: Никита
 Рандомная бегущая строка на основе STM8S003F3P6
 * Copyright (c) 2002-2005 STMicroelectronics
 */
#include "stm8s.h"

unsigned int next = 2;
unsigned int next2;
int eff111[36];
/*unsigned char numbers[29] = {
			 //0x0,0x70,0x88,0x70,0x0,//0
			 //0x0,0x88,0xF8,0x8,0x0,//1
			 //0x0,0x98,0xA8,0xC8,0x0,//2
			 //0x0,0xA8,0xA8,0x70,0x0,//3
			 0x0,0xE0,0x20,0xF8,//4
			 0x0,0xE8,0xA8,0xB8,//5
			 0x0,0x78,0xA8,0xB8,//6
			 0x0,0x80,0x80,0xF8,//7
			 0x0,0xF8,0xA8,0xF8,//8
			 0x0,0xE8,0xA8,0xF8,//9
			 0x0,0xC0,0xD8,0x18//:
	 };*/
int buf[36];
//int buf[29];
int iii = 0;
int ii = 0;
int y = 0;
int l = 10;
int i = 0;	
int fraim;
int x;
int xx = 0;
unsigned int ip;
#define dev_addrw 0b11010000 //запись 0b10100000
#define dev_addrr 0b11010001 //чтение 0b10100001
//============Инициализация микросхемы DC1307===============
void DS1307init (void){//инициализация микросхемы
I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
I2C->SR1 |= (1<<0);
		
//SB=1, очищается чтением регистра SR1 с последующей записью регистра DR с адресом.

		//I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
		//I2C->SR1 |= (1<<0);//отправка посылки СТАРТ
		I2C->DR = dev_addrw;//адрес часовой микросхемы - запись
		I2C->DR = 0b00000000;//вызов регистра секунд
		I2C->DR = 0b01010101;//установка секунд 55
		I2C->CR2 |= (1<<1);//отправка посылки СТОП (остановить генерацию после передачи байта)
		
		I2C->CR2 |= (1<<0);//отправка посылки СТАРТ
		I2C->SR1 |= (1<<0);
		//I2C->SR1 |= (1<<0);//отправка посылки СТАРТ
		I2C->DR = dev_addrw;//адрес часовой микросхемы - запись
		I2C->DR = 0b00000111;//вызов регистра clock out
		I2C->DR = 0b00010000;//включение делителя частоты 1Hz		
		/*delay_ms(2);
    i2c_start ();//отправка посылки СТАРТ
    I2C_SendByte (dev_addrw);//адрес часовой микросхемы - запись
    I2C_SendByte (0b00000000);//вызов регистра секунд (0b00000010)
    I2C_SendByte (0b00000000);//установка секунд 55  01010101
    i2c_stop ();
    
		i2c_start ();//отправка посылки СТАРТ
    I2C_SendByte (dev_addrw);//адрес часовой микросхемы - запись 
    I2C_SendByte (0b00000111);//вызов регистра clock out
    I2C_SendByte (0b00010000);//включение делителя частоты 1Hz
    i2c_stop ();*/	
}
//=================================================================
	 void raand(void)
		 {
		 unsigned char i2;
			int xy;
			next++;
		 if (next > 20) next = 2;
		 for (i2 = 0; i2 < 36; i2++){
		 next = next * 1103515;//1103515245
		   next2 = (next / 655) * 276;// next2 = (next / 65536) * 2768
		   xy = next2 % (327 - 8 + 1) + 8;//x = next2 % (32767 - 8 + 1) + 8
		   if (xy > 327) xy = xy - 327;//if (x > 32767) x = x - 32767;
			 //xy = xy;//(xy & 0b11111000);
			 
		 eff111[i2] = xy;//0b01010111;
		 }
		 }
//=========================Задержка================================
 void delay(int n)
 {
         while(n > 10) n--;
 }
 //=====================
 void clear_matrix(void)
 {
 	 unsigned char i;
 	 for (i = 0;i < 49; i++){
 		 eff111[i] = 0;
 	 }
 }
//==========================ВЫВОД ФРЕЙМА======================================
	 	 	void fraim_out (int o, int e){
										int ipp;
	 	 			if (1) {
	 iii++;
	 	 			buf[35] = eff111[0];//Считали 1ю колонку в буфер
					//buf[28] = numbers[0];//Считали 1ю колонку в буфер

	 	 			for ( ii = 0; ii < 35; ii++)
					//for ( ii = 0; ii < 28; ii++)
	 	 				{
	 	 				eff111[ii] = eff111[ii + 1];//Сдвинули матрицу на один столбец влево
						//numbers[ii] = numbers[ii + 1];//Сдвинули матрицу на один столбец влево
	 	 				 }
	 	 			eff111[35] = buf[35];//Записали содержимое буфера (первую колонку) в конец матрицы
					//numbers[28] = buf[28];
	 	 		
}
for ( ip = 0; ip < 400; ++ip) 
				{
          GPIOC->ODR = eff111[l];//
					//GPIOC->ODR = numbers[l];
					GPIOD->ODR &= ~(1<<6);
					delay (500);//
					GPIOD->ODR |= (1<<6);
					GPIOC->ODR &= ~((1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3));//очистка строк ++
					l--;
	 	 			y++;
	 	 			if (y == 8) {
	 	 				y = 0;
	 	 				l = 8;
				GPIOA->ODR |= (1<<3);
				delay (20);
				GPIOA->ODR &= ~(1<<3);
	 	 			}
			  }
	 	 	}
//==============================================================================
int main(void)
{
//ODR регистр выходных данных
//IDR регистр входных данных
//DDR регистр направления данных
//Настройка портов
  CLK->ECKR |= (1<<0);//Включение HSE осцилятора
	CLK->SWCR |= (1<<1);//Разрешаем переключить источник тактирования
while(CLK->ECKR & (1<<1) == 1){}//Ждем готовности источника тактирования
	CLK->CKDIVR = 0b00011000;//Делитель частоты внутреннего осцилятора = 0; тактовой частоты ЦПУ -2
  CLK->SWR = 0b10110100;//HSE основной источник синхронизации
while (CLK->SWCR & (1<<1) == 1){}// Ждем готовности переключения
	
	GPIOA->DDR |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Выход
	GPIOA->CR1 |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Выход типа Push-pull
	GPIOA->CR2 |= (1<<3);// | (1<<2) | (1<<1);// | (1<<5) | (1<<4) | (1<<3);//Скорость переключения - до 10 МГц.
	
	GPIOD->DDR &= ~((1<<5) | (1<<4) | (1<<3) | (1<<2) | (1<<1));//Вход
	GPIOD->CR1 |= (1<<5) | (1<<4) | (1<<3) | (1<<2) | (1<<1);//Вход с подтягивающим резистором
	GPIOD->CR2 |= (1<<5) | (1<<4) | (1<<3) | (1<<2) | (1<<1);//Скорость переключения - до 10 МГц.
	GPIOD->DDR |= (1<<6);//Выход
  GPIOD->CR1 |= (1<<6);//
	GPIOD->CR2 |= (1<<6);//
	
	GPIOC->DDR |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//выход
	GPIOC->CR1 |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//Выход типа Push-pull 
	GPIOC->CR2 |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);//Скорость переключения - до 10 МГц.
	
	GPIOB->DDR |= (1<<5) | (1<<4);//выход
	GPIOB->CR1 |= (1<<5) | (1<<4);//Выход типа Push-pull 
	GPIOB->CR2 |= (1<<5) | (1<<4);//Скорость переключения - до 10 МГц.
	//===================Настройка I2C========================
	I2C->FREQR = 0b00000010;
	I2C->CCRH &= ~(1<<7);
	I2C->CCRL = 0b00000000;
	I2C->CCRH = 0b00000000;
	I2C->TRISER = 0b00001111;
	I2C->CR1 |= (1<<0);
	I2C->CR2 |= (1<<2);
	
	//I2C->CR2 |= (1<<7) | (1<<1) | (1<<0);

	//I2C->DR;//Регистр данных
	I2C->ITR = 0b00000000;
	
	//========================================================
	raand();
	GPIOA->ODR |= (1<<3);
	delay (20);
	GPIOA->ODR &= ~(1<<3);
    DS1307init();
	while (1){
		unsigned char iu;
	if (iii > 36) {
	 			raand();
	 			iii = 0;
	 		}
			DS1307init();
			fraim_out(fraim, 0);



		//raand();
		/*y++;
				GPIOC->ODR |= (1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3);
				GPIOD->ODR &= ~(1<<6);
				delay (30000);
				delay (30000);
        GPIOC->ODR &= ~((1<<7) | (1<<6) | (1<<5) | (1<<4) | (1<<3));
				GPIOD->ODR |= (1<<6);
				delay (30000);
				delay (30000);
				if (y == 8){
				y = 0;
				GPIOA->ODR |= (1<<3);
				delay (20);
				GPIOA->ODR &= ~(1<<3);
				}*/
				
						}
}



